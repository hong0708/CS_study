# 배낭문제

상태: Not started
체크박스: No

배낭에 담을 수 있는 무게의 제한이 있고 가치와 무게가 있는 짐들을 배낭에 넣을 때 가장 큰 가치를 찾는 문제

### 물건이 분할이 불가능한 경우 : 0-1 배낭 문제

**1- x축엔 가방 0~K 까지의 무게, y축은 물건 N개 개수 만큼의 배열을 만들어준다. 0부터 해서 이전 무게로 갱신하게 할 수 있음**

**2- 행을 차례대로 돌며 아래와 같은 과정을 진행한다.**

**3-1) 현재 물건이 현재 돌고 있는 무게보다(현재 위치) 작다면 바로 [이전 물건][같은 무게] (arr[i-1][j]를 입력해준다.**

**3-2) 현재 물건을 넣어준다. 물건을 넣은 뒤의 남은 무게를 채울 수 있는 최댓값(arr[i-1][j-weight]을 위의 행에서 가져와 더해준다.**

**3-3) 현재 물건을 넣어주는 것보다. 다른 물건들로 채우는 값(arr[i-1][j])을 가져온다.**

**4) 3-1과 3-2 중 더 큰 값을 arr[i][j]에 저장해준다. 이 값은 현재까지의 물건들로 구성할 수 있는 가장 가치 높은 구성이다.**

**5) arr[N][K]는 곧, K무게일 때의 최댓값을 의미한다.**

| 무게 | 가치 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 6 | 13 | 0 | 0 | 0 | 0 | 0 | 13 | 13 |
| 4 | 8 | 0 | 0 | 0 | 8 | 8 | 13 | 13 |
| 3 | 6 | 0 | 0 | 6 | 8 | 8 | 13 | 14 |
| 5 | 12 | 0 | 0 | 6 | 8 | 12 | 13 | 14 |

```python
for i in range(1, n + 1):
    for j in range(1, k + 1):
        w = thing[i][0] # 무게
        v = thing[i][1] # 가치

        if j < w:
            arr[i][j] = arr[i - 1][j]
        else:
            arr[i][j] = max(v + arr[i - 1][j - w], arr[i - 1][j])
print(arr[n][k])

# arr[i][j] = 
# max(현재 물건 가치 + arr[이전 물건][현재 가방 무게 - 현재 물건 무게], arr[이전 물건][현재 가방 무게])

# arr[i][j] = max(v + arr[i - 1][j - w], arr[i - 1][j])
```

### 물건이 분할이 가능한 경우 : 분할 가능 배낭 문제

1- **기본 단위 당 가치를 순서대로 정렬하고 가방의 무게 만큼 진행하면 끝**