# 누적합

상태: Not started
체크박스: No

- 리스트의 특정 구간의 합을 빠르게 구할 수 있는 방법입니다.
- 리스트 안에 데이터의 변화가 없다면 누적된 합의 변동이 없기 때문에 이 점을 활용해 특정 구간의 부분합을 구할 수 있습니다.
- 이전의 값을 미리 저장하는데 이 점이 동적 계획법과 유사한 방법이라 할 수 있습니다.
- 크게 1차원, 2차원 배열에서 많이 활용됩니다.

먼저 1차원 배열입니다. prefix[i] 는 arr[0]+arr[1]...arr[i-1] 이라 할 수 있습니다.

| 6 | 3 | 2 | 9 | 1 | 5 |
| --- | --- | --- | --- | --- | --- |

해당 배열의 누적합은 아래와 같습니다.

| 0 | 6 | 9 | 11 | 20 | 21 | 26 |
| --- | --- | --- | --- | --- | --- | --- |
1. 0번째 인덱스는 배열의 0번째와 같은 값입니다.
2. 현재 i 번째 배열의 값을 i-1번째 누적합 배열의 값을 더해 i 번째 누적합 배열에 저장합니다.
3. 즉 prefix[i] = prefix[i-1] + arr[i] 점화식을 만들 수 있습니다.
4. 만약 i~j번째 인덱스들의 합을 구하고 싶다면 prefix[j+1] - prefix[i]로 해당 값을 알아낼 수 있습니다.(i<j)

다음은 2차원 배열입니다. prefix[i]\[j]는 arr[0][0] + ...arr[i-1][j-1] 이라 할 수 있습니다.

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
|  |  |  | i-1,j |  |
|  |  | i,j-1 | i,j |  |
|  |  |  |  |  |
1. prefix[i][j] 를 구하려면 1차원 배열과 마찬가지로 이전의 누적합을 활용하여 arr[i][j] 값을 더해서 구합니다.
2. prefix[i][j-1] + arr[i][j]를 한다면 arr[i-1][j], arr[i-2][j]...이 부족하고 prefix[i-1][j] + arr[i][j]를 한다면 arr[i][j-1], arr[i][j-2]...가 부족한 상황이 됩니다. 이를 해결하기 위해 prefix[i][j-1] + prefix[i-1][j] + arr[i][j]로 더해줌으로 필요한 arr 데이터 값들을 저장할 수 있습니다.
3. 중복된 값을 제거해 줘야합니다. prefix[i][j-1] + prefix[i-1][j] 을 진행했을 때 prefix[i-1][j-1] 값이 두번 더해지는데 이를 빼줘야 arr의 데이터가 모두 1번씩 더해집니다.
4. 즉, prefix[i][j] = prefix[i][j-1] + prefix[i-1][j] + arr[i-1][j-1] - prefix[i-1][j-1] 과 같은 점화식을 구할 수 있습니다.

만약 x,y 에서 w,z까지의 누적합을 구하고 싶을 때도 유사합니다. (x<w , y<z)

sum = prefix[w+1][z+1] - prefix[x][z+1] - prefix[w+1][y] + prefix[x][y]

prefix[i][j]가 i-1,j-1까지의 합이기 때문에 먼저 w,z +=1 하여 구하고 이후 x,z+1, w+1,y까지의 누적합을 빼고 중복빼진 부분을 다시 더해줘 구해주면 해결 가능합니다.

```python
# 누적합 배열 만들기
for a in range(1, n + 1):
    for b in range(1, n + 1):
        p[a][b] = arr[a - 1][b - 1] + p[a - 1][b] + p[a][b - 1] - p[a - 1][b - 1]

for j in range(m):
    x1, y1, x2, y2 = map(int, input().split())
    print(p[x2][y2] - p[x1 - 1][y2] - p[x2][y1 - 1] + p[x1 - 1][y1 - 1])

```