# 보이어-무어 알고리즘


일반적인 문자열 탐색 즉, 이중 for문을 통한 반복문과는 다른 방식을 통해 시간복잡도를 줄이는 방식입니다.

이중 for문을 통해 반복문을 진행한다면 시간복잡도는 O(N\*\*2)이라 문제 조건의 길이가 길다면 시간초과가 일어날 수 있습니다.

보이어-무어 알고리즘의 진행 방식은 아래와 같습니다.

- 패턴의 오른쪽 끝 문자와 문자열의 현재 위치 문자가 일치하는지 검사합니다.
- 만약 패턴의 오른쪽 끝 문자와 문자열의 현재 위치 문자가 일치한다면 왼쪽으로 검사를 이어나갑니다.
- 만약 검사 중 일치하지 않는 다면 패턴의 길이만큼을 넘어가 새로 검사를 시작합니다.
- 반대로 패턴의 오른쪽 끝 문자와 문자열의 현재 위치 문자가 일치 하지 않는다면 먼저 문자열의 현재 위치 문자가 패턴에 있는지 검사를 진행합니다.
- 만약 있다면 그만큼 인덱스를 변경해 검사를 진행하고 없다면 다시 패턴의 길이만큼 움직입니다.

문자열 abdefabc와 abc 패턴 비교 예시입니다.

| a | b | d | e | f | a | b | c |
| --- | --- | --- | --- | --- | --- | --- | --- |

| a | b | c |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |

먼저 d 와 c가 비교됩니다. 이는 일치하지 않고 d가 패턴에 없기 때문에 3만큼 이동합니다.

| a | b | d | e | f | a | b | c |
| --- | --- | --- | --- | --- | --- | --- | --- |

|  |  |  | a | b | c |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |

위와 동일한 경우로 a와 c가 비교됩니다. 하지만 일치하지 않습니다. 위 경우와 다르게 a가 abc에서 a에 있기때문에 2만큼 이동을 진행합니다.

| a | b | d | e | f | a | b | c |
| --- | --- | --- | --- | --- | --- | --- | --- |

|  |  |  |  |  | a | b | c |
| --- | --- | --- | --- | --- | --- | --- | --- |

마지막으로 일치하는 경우를 찾았기 때문에 True를 리턴합니다.

아래는 해당 알고리즘을 적용한 예제 코드입니다.

```python
# 문자열 검색하는 보이어 무어 알고리즘
def boyer_moore(txt, pattern):
    t = len(txt)
    p = len(pattern)
    # 기준점이 되는 위치
    loc = 0
    # 반복은 최대 텍스트 길이 - 패턴 길이
    while loc <= t - p:
        # 뒤에서 부터 비교하기 때문에 패턴의 길이 -1 만큼 인덱스를 설정해 점점 왼쪽 문자열을 비교
        now_loc = p - 1
        while now_loc >= 0:
            # 끝글자부터 비교
            # 같다면 하나씩 감소하면서 비교 이어감
            # 글자가 틀리다면 제일마지막 글자 기준으로 find 함수를 호출하여 해당 문자가 패턴에 있는지 판단
            if pattern[now_loc] != txt[loc + now_loc]:
                move = find(pattern, txt[loc + p - 1])
                break
            now_loc = now_loc - 1
        # 인덱스가 -1이라는 뜻은 모든 글자가 동일해 계속 감소했다는 것
        if now_loc == -1:
            return True
        else:
            # -1이 아니라면 글자를 못찾은 것이므로 find에서 넘겨준 값만큼 옆으로 이동한다.
            loc += move
    return False

def find(pattern, char):
    for i in range(len(pattern) - 2, -1, -1):
        # 마지막 글자와 패턴중 일치 한다면 해당 위치 만큼만 이동
        if pattern[i] == char:
            return len(pattern) - i - 1
        # 일치하는 글자가 없다면 패턴의 길이만큼 이동
    return len(pattern)

```
